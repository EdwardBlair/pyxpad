#!/usr/bin/env python
 
from PySide.QtGui import *
from PySide.QtCore import *

from pyxpad_main import *
from configdialog import ConfigDialog

import cPickle as pickle
from StringIO import StringIO
import sys, os
import re
import fnmatch  # For matching names to wildcard patterns
from keyword import iskeyword  # Test if a string is a keyword

# On some installations (Python 2.6 only?) need to convert text using QTextCodec
codec = QTextCodec.codecForName("UTF-8")
def toStr(uni):
    return str(codec.fromUnicode(uni))

class Sources:
    sources = []  # List of sources
    
    def __init__(self, mainwindow):
        self.main = mainwindow
        self.main.sourceDescription.stateChanged.connect(self.updateDisplay)
        
        self.groupIcon = QtGui.QIcon()	
        self.groupIcon.addPixmap(mainwindow.style().standardPixmap(QtGui.QStyle.SP_DirClosedIcon),
                                 QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.groupIcon.addPixmap(mainwindow.style().standardPixmap(QtGui.QStyle.SP_DirOpenIcon),
                                 QtGui.QIcon.Normal, QtGui.QIcon.On)
        self.keyIcon = QtGui.QIcon()
        self.keyIcon.addPixmap(mainwindow.style().standardPixmap(QtGui.QStyle.SP_FileIcon))
        
        self.main.treeView.itemSelectionChanged.connect(self.updateDisplay)
        self.main.tracePattern.returnPressed.connect(self.updateDisplay)
        self.main.treeView.setContextMenuPolicy(Qt.CustomContextMenu)  # Enable popup menus

        # Context menu
        self.main.treeView.customContextMenuRequested.connect(self.handlePopupMenu)

        # Context menu actions
        self.actionAdd = QAction("Add", self.main, statusTip="Add a new source")
        
        self.actionDelete = QAction("Delete", self.main, statusTip="Remove source from tree")
        self.actionDelete.triggered.connect(self.deleteSource)
        
        self.actionConfig = QAction("Configure", self.main, statusTip="Configure source")
        self.actionConfig.triggered.connect(self.configureSource)
        
    def saveState(self, f):
        pickle.dump(self.sources, f)
        
    def loadState(self, f):        
        sources = pickle.load(f)
        for s in sources:
            self.addSource(s)
        self.updateDisplay()
        
    def handlePopupMenu(self):
        
        menu = QMenu()
        menu.addAction(self.actionAdd)
        
        selected = self.main.treeView.selectedItems()
        if len(selected) != 0:
            if selected[0].source.__dict__.has_key('config'):
                menu.addAction(self.actionConfig)
            menu.addAction(self.actionDelete)
            
        menu.exec_(QCursor.pos())

    def addNetCDF(self):
        """
        Add a NetCDF file as a data source
        """
        try:
            from datafile import NetCDFDataSource
        except:
            self.main.write("Sorry, no NetCDF support")
            return
        try:
            # Get the file name
            tr = self.main.tr
            fname, _ = QFileDialog.getOpenFileName(self.main, tr('Open file'), '.', filter=tr("NetCDF files (*.nc *.cdl)"))
            fname = toStr(fname)
            if (fname == None) or (fname == ""):
                return # Cancelled
        
            s = NetCDFDataSource(fname)
            
            self.addSource(s)
            self.updateDisplay()
        except:
            self.main.write("Error creating NetCDFDataSource")
            self.main.write(str(sys.exc_info()))

    def addXPADtree(self):
        try:
            from xpadsource import XPadSource
        except:
            self.main.write("Sorry, no XPAD tree support")
            self.main.write(str(sys.exc_info()))
            return
        
        try:
            # Select the directory
            tr = self.main.tr
            dname = QFileDialog.getExistingDirectory(self.main, tr('Open XPAD directory'), QDir.currentPath())
            dname = toStr(dname)
            if (dname == "") or (dname == None):
                return
            # Create data source
            s = XPadSource(dname)
            
            # Add data source and update
            self.addSource(s)
            self.updateDisplay()
        except:
            self.main.write("Error creating XPadSource")
            self.main.write(str(sys.exc_info()))
            raise

    def addBOUT(self):
        """
        Add a BOUT++ directory source
        """
        try:
            from boutsource import BoutDataSource
        except:
            self.main.write("Sorry, no BOUT++ support")
            return
        
        
    def addSource(self, source):
        self.sources.append(source)
        it = QTreeWidgetItem(self.main.treeView, [source.label])
        it.setIcon(0, self.groupIcon)
        it.source = source
        self.main.treeView.addTopLevelItem(it)
        
        def buildtree(parent, it):
            # Check for children
            try:
                for child in parent.children:
                    itchild = QTreeWidgetItem(it, [child.label])
                    itchild.source = child
                    buildtree(child, itchild) # Add child's children
                    it.addChild(itchild)
            except AttributeError:
                # Probably no children
                return

        buildtree(source, it)
    
    def deleteSource(self):
        tree = self.main.treeView
        selected = tree.selectedItems()
        if len(selected) == 0:
            return
        source =  selected[0].source
        tree.takeTopLevelItem(tree.indexOfTopLevelItem(selected[0])) # Remove from tree
        # Remove from list of sources
        i = self.sources.index(source)
        del self.sources[i]
        # Update the display
        self.updateDisplay()
        
    def configureSource(self):
        selected = self.main.treeView.selectedItems()
        if len(selected) == 0:
            return
        source =  selected[0].source
        c = ConfigDialog(source.config, self.main)
        c.exec_()
        
    def updateDisplay(self):
        table = self.main.sourceTable
        # Find which source is selected, and update table view
        selected = self.main.treeView.selectedItems()
        if len(selected) == 0:
            table.clearContents()
            table.setRowCount(0)
            return
        s = selected[0].source

        # Check if any items selected
        selecteditems = table.selectedItems()
        selectedvars = []
        nextra = 0
        for item in selecteditems:
            if item.__dict__.has_key('source'):
                name = toStr(item.text())
                selectedvars.append(  (name, item.source) )
                if item.source != s:
                    nextra += 1
        
        table.clearContents()  # Clear the table and selections

        pattern = toStr(self.main.tracePattern.text())
        if pattern == "":
            varNames = s.varNames
        else:
            # Filter the variable names
            varNames = [name for name in s.varNames if fnmatch.fnmatch(name.lower(), pattern.lower())]
        
        varNames.sort(key=str.lower)
        
        if self.main.sourceDescription.isChecked():
            # Provide description for each variable (if available)
            
            table.setColumnCount(2)
            table.setRowCount(len(varNames) + nextra)
            table.setSelectionBehavior(QAbstractItemView.SelectRows)
            
            def addVar(name, source, selected=False):
                var = source.variables[name]
                item = QTableWidgetItem(name)
                item.source = source
                table.setItem(addVar.ind, 0, item)
                item.setSelected(selected)
                comment = var.desc
                if comment == "":
                    comment = var.label
                    if var.units != "":
                        comment += " ("+var.units+") "
                        
                if (var.dim != None) and (var.dim != []):
                    comment += " [" + var.dim[0].name
                    for d in var.dim[1:]:
                        comment += ", " + d.name
                        comment += "] "
                item = QTableWidgetItem(comment)
                table.setItem(addVar.ind, 1, item)
                item.setSelected(selected)
                addVar.ind += 1
        else:
            # Just a list of variable names. Can use multiple columns
            maxrows = 20
            n = len(varNames) + nextra
            ncols = int(n / maxrows) + 1
            table.setColumnCount(ncols)
            table.setRowCount(min([n, maxrows]))
            table.setSelectionBehavior(QAbstractItemView.SelectItems)
            
            def addVar(name, source, selected=False):
                row = addVar.ind % maxrows
                col = int(addVar.ind / maxrows)
                item = QTableWidgetItem(name)
                item.source = source
                table.setItem(row, col, item)
                item.setSelected(selected)
                addVar.ind += 1
        
        addVar.ind = 0
        for name, source in selectedvars:
            addVar(name, source, True)
        sel = [name for name, source in selectedvars if source == s]
        for name in varNames:
            if not name in sel:
                addVar(name, s)
        
    def read(self):
        """
        Read the selected data and return as a list of data items
        
        """
        
        # Get list of shots
        shotlist = toStr(self.main.shotInput.text()).split(',')
        
        table = self.main.sourceTable
        tableitems = table.selectedItems()
        data = []
        for item in tableitems:
            if item.__dict__.has_key('source'):
                name = toStr(item.text())
                
                for shot in shotlist:
                    s = "Reading " + name + " from " + item.source.label
                    if shot != "":
                        s += " shot = " + shot
                    self.main.write(s)
                    data.append(item.source.read(name, shot))
            else:
                print "Ignoring "+item.text()
        return data
                
        
class PyXPad(QtGui.QMainWindow, Ui_MainWindow):
    """
    
    Attributes
    
      data    Dictionary of variables containing user data
    """
    def __init__(self, parent=None, loadfile=None):
        super(PyXPad, self).__init__(parent)
        self.setupUi(self)
        
        self.sources = Sources(self)  # Handles data sources
        self.data = {} # User data 
        
        # File menu
        self.actionNetCDF_file.triggered.connect(self.sources.addNetCDF)
        self.actionXPAD_tree.triggered.connect(self.sources.addXPADtree)
        self.actionExit.triggered.connect(self.close)

        self.actionLoadState.triggered.connect(self.loadState)
        self.actionSaveState.triggered.connect(self.saveState)

        # Graphics menu
        self.actionPlot.triggered.connect(self.handlePlot)
        self.actionXYPlot.triggered.connect(self.handleXYPlot)
        self.actionContour.triggered.connect(lambda : self.handleCommandAction("contour"))
        self.actionContour_filled.triggered.connect(lambda : self.handleCommandAction("contourf"))
        
        # Sources tab 
        self.readDataButton.clicked.connect(self.readData)
        self.shotInput.returnPressed.connect(self.readData)

        self.commandInput.returnPressed.connect(self.commandEntered)
        self.commandButton.clicked.connect(self.commandEntered)
        
        # Data tab
        self.dataTable.cellChanged.connect(self.dataTableChanged)
        
        try:
            from matplotlib_widget import MatplotlibWidget
            self.DataPlot = MatplotlibWidget(self.plotTab)
        except:
            raise

        # Load state
        if loadfile != None:
            self.loadState(loadfile)

    def saveState(self, filename = None):
        if filename == None:
            tr = self.tr
            filename, _ = QFileDialog.getSaveFileName(self, filter=tr("PyXPad save file (*.pyx)"))
            filename = toStr(filename)
        if (filename == None) or (filename == ""):
            return
        try:
            f = open(filename, 'w')
            self.sources.saveState(f)
            pickle.dump(self.data, f)
            f.close()
            self.write("** Saved state to file '"+filename+"'")
        except:
            e = sys.exc_info()
            self.write("Could not save state to file '"+filename+"'")
            self.write("\t ->" + str(e[1]))

    def loadState(self, filename = None):
        if filename == None:
            tr = self.tr
            filename, _ = QFileDialog.getOpenFileName(self, tr('Open file'), '.', filter=tr("PyXPad save file (*.pyx)"))
            filename = toStr(filename)
        if (filename == None) or (filename == ""):
            return # Cancelled
        try:
            f = open(filename, 'r')
            self.sources.loadState(f)
            self.data = pickle.load(f)
            f.close()
            # Update tables, lists
            self.updateDataTable()
            self.write("** Loaded state from file '"+filename+"'")
        except:
            e = sys.exc_info()
            self.write("Could not load state from file '"+filename+"'")
            self.write("\t ->" + str(e[1]))
        
    def closeEvent(self, event):
        reply = QtGui.QMessageBox.question(self, 'Message',
                                           "Are you sure to quit?", QtGui.QMessageBox.Yes | 
                                           QtGui.QMessageBox.No, QtGui.QMessageBox.Yes)
        
        if reply == QtGui.QMessageBox.Yes:
            event.accept()
        else:
            event.ignore()
    
    def write(self, text):
        """
        Write some log text
        """
        self.textOutput.append(text)

    def makeUnique(self, name):
        # First make sure the name is a valid variable name
        name = re.sub('\W|^(?=\d)','_', name) # Replace invalid characters with '_'
        
        if iskeyword(name): # Check if name is a keyword
            name += '2'

        if self.data.has_key(name):
            # Name is already in the list. Add a number to the end to make it unique
            i = 1
            while self.data.has_key(name + "_"+str(i)):
                i += 1
            return name + "_"+str(i)
        return name
        
    def readData(self):
        # Get the data from the source as a list
        newdata = self.sources.read()
        if (newdata == None) or (newdata == []):
            return  # No data read
        
        # Add to the data dictionary
        for item in newdata:
            try:
                # Need to make the name unique
                name = self.makeUnique(item.name)
                self.data[name] = item
            except:
                self.write("Error adding item '"+str(item)+"'")
        
        self.updateDataTable()
        # Switch to data tab
        self.tabWidget.setCurrentWidget(self.dataTab)

    def updateDataTable(self):
        """
        Updates the table of data based on self.data dictionary
        """
        n = len(self.data)
        table = self.dataTable
        table.setSortingEnabled(False)
        self.dataTable.cellChanged.disconnect(self.dataTableChanged)
        table.setRowCount(n)
        for row, name in enumerate(self.data):
            item = self.data[name]
            it = QTableWidgetItem(name)
            it.oldname = name # Save this for when it's changed
            table.setItem(row, 0, it)
            
            # Assume it's an XPadDataItem
            try:
                it = QTableWidgetItem(item.source)
                it.setFlags(it.flags() ^ Qt.ItemIsEditable); # Make source read only
                table.setItem(row, 1, it)
            except:
                table.setItem(row, 1, QTableWidgetItem(""))    
            
            try:
                it = QTableWidgetItem(item.name)
                it.setFlags(it.flags() ^ Qt.ItemIsEditable); # Make trace read only
                table.setItem(row, 2, it)
            except:
                table.setItem(row, 2, QTableWidgetItem(""))
                
            try:
                try:
                    comment = item.comment
                except AttributeError:
                    comment = item.desc
                    if comment == "":
                        comment = item.label
                        if item.units != "":
                            comment += " ("+item.units+") "
                
                    if item.dim != []:
                        comment += " [" + item.dim[0].name
                        for d in item.dim[1:]:
                            comment += ", " + d.name
                        comment += "] "
                    else:
                        comment += " = " + str(item.data)
                
                table.setItem(row, 3, QTableWidgetItem(comment))
            except:
                table.setItem(row, 3, QTableWidgetItem(str(item)))
            
        table.setSortingEnabled(True)
        self.dataTable.cellChanged.connect(self.dataTableChanged)
        
    def dataTableChanged(self, row, col):
        if col == 0:
            # The name of the variable
            it = self.dataTable.item(row, col)
            name = toStr(it.text())
            oldname = it.oldname
            if name == oldname:
                return # Not really changed
            
            # Need to make sure new name is unique and valid
            name = self.makeUnique(name)
            it.setText(name)
            it.oldname = name
            self.data[name] = self.data[oldname]
            del self.data[oldname]
            
        if col == 3:
            # Changing the comment
            comment = self.dataTable.item(row, col).text()
            name = self.dataTable.item(row, 0).text()
            self.data[name].comment = comment
            
        print row, col
        
    def commandEntered(self):
        # Get the command text and clear the text box
        cmd = toStr(self.commandInput.text())
        self.commandInput.clear()
        self.runCommand(cmd)
        
    def selectedDataNames(self):
        # Find which items are selected in the data table
        items = self.dataTable.selectedItems() # All selected items
        if len(items) == 0:
            return []
        names = []  # List of selected data names
        for it in items:
            try:
                names.append(it.oldname)
            except AttributeError:
                pass # Ignore if doesn't have a name
        return names

    ##################### Plot menu actions #####################

    def handlePlot(self):
        # Find which items are selected
        names = self.selectedDataNames()
        if len(names) == 0:
            return
        
        # Sort by trace name
        def trace(name):
            try:
                return self.data[name].name
            except:
                return ""
        namelist = [ (name, trace(name)) for name in names ]
        values = set(map(lambda x:x[1], namelist))
        groups = [[y[0] for y in namelist if y[1]==x] for x in values]
        
        def plotStr(item):
            if len(item) < 2:
                return item[0]
            s = "[" + item[0]
            for n in item[1:]:
                s += ", " + n
            s += "]"
            return s
        
        # Create a command to execute
        cmd = "plot("+plotStr(groups[0])
        for g in groups[1:]:
            cmd += ", "+plotStr(g)
        cmd += ")"
        
        # Run the command within sandboxed environment
        # Also shows user the command which can be entered
        self.runCommand(cmd)
        self.tabWidget.setCurrentWidget(self.plotTab)

    def handleXYPlot(self):
        names = self.selectedDataNames()
        if len(names) != 2:
            self.write("** Two data items must be selected for X-Y plotting")
            return
        # Run the command in sandbox
        self.runCommand("plotxy( "+names[0]+", "+names[1]+")")
        self.tabWidget.setCurrentWidget(self.plotTab)

    def handleCommandAction(self, command):
        names = self.selectedDataNames()
        if len(names) != 1:
            self.write("** One data item must be selected for "+command)
            return
        # Run the command in sandbox
        self.runCommand(command+"( "+names[0]+" )")
        
    def runCommand(self, cmd):
        # Output the command
        self.write(">>> " + cmd)
        
        glob = globals()
        glob['plot']     = self.DataPlot.plot
        glob['plotxy']   = self.DataPlot.plotxy
        glob['contour']  = self.DataPlot.contour
        glob['contourf'] = self.DataPlot.contourf
        # Evaluate the command, catching any exceptions
        # Local scope is set to self.data to allow access to user data
        # To capture print statements stdout is temporarily directed to a StringIO buffer
        buffer = StringIO()
        oldstdout = sys.stdout
        sys.stdout = buffer
        try:
            exec(cmd, glob, self.data)
        except:
            e = sys.exc_info()
            self.write("Error: " + str(e[0]))
            self.write("Reason: " + str(e[1]))
        sys.stdout = oldstdout
        output = buffer.getvalue()
        if len(output) > 0:
            self.write(output)
        self.updateDataTable()
 
if __name__ == "__main__":
    app = QtGui.QApplication(sys.argv)
    path=os.path.dirname(sys.argv[0])
    window = PyXPad(loadfile=path+"/default.pyx")
    window.show()
    sys.exit(app.exec_())

